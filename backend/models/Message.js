const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  // Conversation participants
  conversation: {
    patient: {
      type: mongoose.Schema.ObjectId,
      ref: 'User',
      required: [true, 'Patient is required']
    },
    doctor: {
      type: mongoose.Schema.ObjectId,
      ref: 'Doctor',
      required: [true, 'Doctor is required']
    }
  },
  
  // Message details
  sender: {
    id: {
      type: mongoose.Schema.ObjectId,
      required: [true, 'Sender ID is required']
    },
    type: {
      type: String,
      enum: ['patient', 'doctor'],
      required: [true, 'Sender type is required']
    },
    name: {
      type: String,
      required: true
    }
  },
  
  // Message content
  content: {
    text: {
      type: String,
      maxlength: [1000, 'Message cannot exceed 1000 characters']
    },
    type: {
      type: String,
      enum: ['text', 'image', 'document', 'audio', 'video', 'prescription', 'appointment'],
      default: 'text',
      required: true
    }
  },
  
  // File attachments
  attachments: [{
    filename: {
      type: String,
      required: true
    },
    originalName: String,
    url: {
      type: String,
      required: true
    },
    publicId: String, // For Cloudinary
    mimeType: String,
    size: Number, // in bytes
    thumbnail: String // For images/videos
  }],
  
  // Message status
  status: {
    type: String,
    enum: ['sent', 'delivered', 'read'],
    default: 'sent'
  },
  
  // Timestamps
  sentAt: {
    type: Date,
    default: Date.now
  },
  deliveredAt: Date,
  readAt: Date,
  
  // Message metadata
  isEdited: {
    type: Boolean,
    default: false
  },
  editedAt: Date,
  originalMessage: String, // Store original message if edited
  
  isDeleted: {
    type: Boolean,
    default: false
  },
  deletedAt: Date,
  deletedBy: {
    type: String,
    enum: ['patient', 'doctor', 'admin']
  },
  
  // Priority and urgency
  priority: {
    type: String,
    enum: ['low', 'normal', 'high', 'urgent'],
    default: 'normal'
  },
  
  // Reply to message
  replyTo: {
    type: mongoose.Schema.ObjectId,
    ref: 'Message'
  },
  
  // Message reactions
  reactions: [{
    user: {
      type: mongoose.Schema.ObjectId,
      required: true
    },
    userType: {
      type: String,
      enum: ['patient', 'doctor'],
      required: true
    },
    emoji: {
      type: String,
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Encryption
  isEncrypted: {
    type: Boolean,
    default: false
  },
  encryptionKey: String,
  
  // Auto-generated responses
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  autoResponseType: {
    type: String,
    enum: ['greeting', 'appointment_reminder', 'prescription_ready', 'follow_up']
  },
  
  // Message templates
  templateId: String,
  templateVariables: mongoose.Schema.Types.Mixed,
  
  // Compliance and audit
  isArchived: {
    type: Boolean,
    default: false
  },
  archivedAt: Date,
  
  // Appointment or prescription reference
  relatedAppointment: {
    type: mongoose.Schema.ObjectId,
    ref: 'Appointment'
  },
  relatedPrescription: {
    type: mongoose.Schema.ObjectId,
    ref: 'Prescription'
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for formatted time
messageSchema.virtual('formattedTime').get(function() {
  return this.sentAt.toLocaleTimeString('en-IN', {
    hour: '2-digit',
    minute: '2-digit'
  });
});

// Virtual for time ago
messageSchema.virtual('timeAgo').get(function() {
  const now = new Date();
  const diff = now - this.sentAt;
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  
  if (days > 0) return `${days}d ago`;
  if (hours > 0) return `${hours}h ago`;
  if (minutes > 0) return `${minutes}m ago`;
  return 'Just now';
});

// Virtual for conversation ID
messageSchema.virtual('conversationId').get(function() {
  return `${this.conversation.patient}_${this.conversation.doctor}`;
});

// Method to mark as read
messageSchema.methods.markAsRead = function() {
  if (this.status !== 'read') {
    this.status = 'read';
    this.readAt = new Date();
    return this.save();
  }
};

// Method to mark as delivered
messageSchema.methods.markAsDelivered = function() {
  if (this.status === 'sent') {
    this.status = 'delivered';
    this.deliveredAt = new Date();
    return this.save();
  }
};

// Static method to get conversation messages
messageSchema.statics.getConversation = function(patientId, doctorId, page = 1, limit = 50) {
  return this.find({
    'conversation.patient': patientId,
    'conversation.doctor': doctorId,
    isDeleted: false
  })
  .populate('replyTo', 'content.text sender.name')
  .sort({ sentAt: -1 })
  .limit(limit * 1)
  .skip((page - 1) * limit);
};

// Static method to mark conversation as read
messageSchema.statics.markConversationAsRead = function(patientId, doctorId, userId, userType) {
  return this.updateMany({
    'conversation.patient': patientId,
    'conversation.doctor': doctorId,
    'sender.id': { $ne: userId },
    status: { $ne: 'read' }
  }, {
    status: 'read',
    readAt: new Date()
  });
};

// Static method to get unread count
messageSchema.statics.getUnreadCount = function(userId, userType) {
  const filter = {
    status: { $ne: 'read' },
    'sender.type': { $ne: userType },
    isDeleted: false
  };
  
  if (userType === 'patient') {
    filter['conversation.patient'] = userId;
  } else {
    filter['conversation.doctor'] = userId;
  }
  
  return this.countDocuments(filter);
};

// Index for performance
messageSchema.index({ 'conversation.patient': 1, 'conversation.doctor': 1, sentAt: -1 });
messageSchema.index({ 'sender.id': 1, sentAt: -1 });
messageSchema.index({ status: 1, 'conversation.patient': 1, 'conversation.doctor': 1 });
messageSchema.index({ sentAt: -1 });
messageSchema.index({ isDeleted: 1, sentAt: -1 });

module.exports = mongoose.model('Message', messageSchema); 